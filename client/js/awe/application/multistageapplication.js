/*
 * Application object for controlling several layered Canvas Objects with
 * associated EaselJS stages.
 * 
 * The application controller itself adds two stages and one dom layer:
 * - notification stage
 * - menue stage (HUD)
 * - dialog layer (DOM layer for modal HTML dialogs)
 *
 * Screen controllers are used to add and exchange any number of stages 
 * or dom layers below these three application layers. So it's possible 
 * to switch between different screens of the applicaton, while always
 * having centrally-controller menue, notification and dialog layers on
 * top.
 *
 * Mouse events
 * ============
 * 
 * - we catch mouse events globally and pass them to presentScreenControllers
 *   in case they listen to the particular event (by implementing an 
 *   onMouse...  handler).
 * - one thing to note: we don't use clicks generated by the browser but
 *   generate them ourselves. therefore we always catch the mouseUp event
 *   and determine, whether or not to generate clicks on views.
 * - from the controller standpoint, a single click looks like (produces 
 *   these) events: mouseDown, --- click, mouseUp. 
 */
window.AWE.MultiStageApplication = Ember.Application.extend(function() {
  
  var oldMouseX = 0, mouseX = 0, mouseY = 0, oldMouseY = 0;
  var hoveredView=null;
  var stageHovered=-1;
  var nextMouseOverTest = new Date(1970).getTime();
  var mouseOverTestTimeout = 200; // test every x ms

  return {
    
    presentScreenController: null,    
    readyForRunloop: false,

    
    screenContentAnchor: $('#screen-content'),
    notificationLayerAnchor: $('#notification-layer'),
    hudLayerAnchor: $('#hud-layer'),
    dialogLayerAnchor: $('#dialog-layer'),
        
    ownStages: null,
    allStages: null,
    
    isModal: false,
  
  
    /** custom object initialization goes here. */
    init: function() {
      var self = this;
      this._super();
      this.set('ownStages', []); // TODO: setup HUD, notifications, etc.
      $('body').mousemove(function(event) {
        mouseX = event.pageX; 
        mouseY = event.pageY;
      });
      // register controller to receive click events in screen
      $('body').mouseup(function(evt) {
        console.log('Mouse up event in multi stage application controller.');
        self.handleMouseUp(evt);
      });
    },
  
    readyToRun: function() { this.readyForRunloop = true; },
  
    generateClickIfNeeded: function(evt) {
      var presentScreenController = this.get('presentScreenController');

      if (presentScreenController && presentScreenController.isScrolling()) {
        return ; // just ignore it here!
      }
      
      var allStages = this.get('allStages');
      // TODO: can we use stage.mouseX here or should we better apply the stage-transformations to pageX?
      
      var target = null, relX, relY;
	    for (var layer=0; layer < allStages.length && !target; layer++) {
	      targetLayer = layer;
	      if (allStages[layer].stage.mouseInBounds && !allStages[layer].transparent) {
	        var stage = allStages[layer].stage;
	        target = stage.getObjectUnderPoint(stage.mouseX, stage.mouseY); // TODO: don't use absolute evt.pageX here, right?!
	        relX= stage.mouseX;  // store coordinates in stage's local coordinate system
	        relY= stage.mouseY;
	      }
	    }

      if (target) {
        if (target && target.view && target.view.onClick) {
          target.view.onClick(evt); // TODO: I think this is wrong; we somehow need to get the relative coordinates in.
        }
        else if (target && target.onClick) {
          target.onClick(evt);
        }
      }
      else if (this.get('presentScreenController').onClick) {    // no view hit, let the event bubble to controller (TODO: make this a pattern through views and controllers, aka repsonder-chain)
        this.get('presentScreenController').onClick(evt);
      }      
    },
  
    /** passes a click in the browser window either to the view that was hit
     * or to the present screen controller that gets the chance to handle the
     * otherwise unhandled click. */
    handleMouseUp:  function(evt) {                
      var presentScreenController = this.get('presentScreenController');
      this.generateClickIfNeeded(evt);
      
      // finally pass the mouse up event itself to controller, if it listens
      if (presentScreenController && presentScreenController.onMouseUp) {   
        presentScreenController.onMouseUp(evt);
      }
    },  
  
    /** finds the easelJS DisplayObject that the mouse is over and generates
     * onMouseOver and onMouseOut events as needed on state changes. Differing
     * from easel's implementation, our version DOES know about the layering
     * of mulitple stages. It will deliver events only to one object at a time 
     * (DisplayObject on the top-most stage) and it will also correctly 
     * generate a MouseOut event when the mouse pointer enters a view on another,
     * overlapping stage. */
	  testMouseOver: function() {
	    
	    if (nextMouseOverTest > new Date().getTime()) {
	      return ;
	    }

	    if (mouseX === oldMouseX && mouseY === oldMouseY) { 
	      return ;
	    }	    
	    oldMouseX = mouseX; 
	    oldMouseY = mouseY; 
	    
	    nextMouseOverTest = new Date().getTime() + mouseOverTestTimeout;

	    var allStages = this.get('allStages');
   
	    if (!allStages || allStages.length === 0) {
	      return ;
	    }
	    	    
	    // start with top-most stage, find the view that is hit by the mouse pointer.
	    // Only continue with next stage in stack, in case no view is hit at present
	    // stage.
	    var target = null;
	    var relX, relY;
	    var targetLayer = -1;
	    for (var layer=0; layer < allStages.length && !target; layer++) {
	      targetLayer = layer;
	      if (allStages[layer].stage.mouseInBounds && !allStages[layer].transparent) {
	        var stage = allStages[layer].stage;
	        target = stage.getObjectUnderPoint(stage.mouseX, stage.mouseY);
	        relX= stage.mouseX;  // store coordinates in stage's local coordinate system
	        relY= stage.mouseY;
	      }
	    }
	    
	    // in case the state changed (another view (or nothing) is hit), generate and
	    // send the correct mouseout / mouseover events.
	    if (hoveredView != target) {
	      if (hoveredView && hoveredView.onMouseOut && stageHovered >= 0 && allStages[stageHovered].mouseOverEvents) {
	        hoveredView.onMouseOut(new MouseEvent("onMouseOut", relX, relY, hoveredView));
	      }
	      hoveredView = target;
	      stageHovered = targetLayer;
	  
	      if (target && target.onMouseOver && allStages[targetLayer].mouseOverEvents) {
	        target.onMouseOver(new MouseEvent("onMouseOver", relX, relY, target));
	      }
	    }
	  },
    
    
    /** registers the runloop to be started with next animation frame. Triggered
     * by window.requestAnimationFrame. */
    startRunloop: function() { 
      window.requestAnimFrame(function(self) { return function() {self.runloop(); }; }(this)); // wrap it to keep context (this) correct
    },
    
    
    
    /** the application's runloop. Does basic stuff needed by the application and then hands over
     * control to the view controller that has to do all the real work. The idea behind implementing
     * the runloop inside view controllers is to spread the application logic for different screens
     * (map screen, settlement screen, news screen, message center) among individual, unrelated
     * classes. That is, each screen should be able to implement it's own application logic, so that
     * it can choose the best technique for the particular task (e.g. canvas for the map, basic HTML
     * for sending and receiving messages.) */
    runloop: function() { 
      if (this.get('ready') && this.get('presentScreenController')) {
        this.testMouseOver();
        this.get('presentScreenController').runloop();      // hand over control to present screen controller
      }
      window.requestAnimFrame(function(self) { return function() {self.runloop(); }; }(this));  // request next animation frame that will initiate the next cycle of the runloop
    },
    
    setModal: function(state) {
      if (this.get('isModal') != state) {
        // respond to state chage and do the necessary stuff
        //   add / remove darkened-out layer
        //   disable / enable mouse-over-events
      }
      this.set('isModal', state);
    },
    
    onMouseDown: function(evt) {
      var controller = this.get('presentScreenController');
      if (controller && controller.onMouseDown) {
        controller.onMouseDown(evt);
      }
    },
    
    
    onMouseWheel: function(evt) {
      var controller = this.get('presentScreenController');
      if (controller && controller.onMouseWheel) {   
        controller.onMouseWheel(evt);
      }
    },
    

    onMouseLeave: function(evt) {
      var controller = this.get('presentScreenController');
      if (controller && controller.onMouseLeave) {   
        controller.onMouseLeave(evt);
      }
    },
    
    onResize: function(evt) {
      var controller = this.get('presentScreenController');
      if (controller && controller.onResize) {
        controller.onResize(evt);
      }
    },
    
    bindEventHandlers: function(allStages, controller) {
      var self = this;
      
      if (controller.onMouseDown) {
        // register controller to receive mouse-down events in screen
        $('body').mousedown(function(evt) {
          self.onMouseDown(evt);
        });
      }
    
      
      if (controller.onMouseLeave) {
        // register controller to receive mouse-down events in screen
        $('body').mouseleave(function(evt) {
          self.onMouseLeave(evt);
        });
      }      
      
      // register controller to receive window-resize events (from browser window) 
      // in order to adapt it's own window / display area
      if (controller.onResize) {
        $(window).resize(function(evt){
          self.onResize(evt);
        });
      }
      
      // register controller to receive mouse-wheel events in screen
      if (controller.onMouseWheel) {
        $(window).bind('mousewheel', function() {
          self.onMouseWheel();
        });
      
        // register controller to receive mouse-wheel events in screen (mozilla)
        $(window).bind('DOMMouseScroll', function(evt) {
          that.onMouseWheel(evt);
        });
      }
    },
    
    unbindEventHandlers: function(stages) {
      $(window).unbind('mousedown');
      $(window).unbind('mousewheel');     // remove all event handlers that were bound to the window.
      $(window).unbind('DOMMouseScroll');   
      $(window).unbind('resize');        
      $(window).unbind('mouseleave');        
    },
    
    append: function(controller) {
      if (this.get('screenContentAnchor')) {
        var controllerStages = controller.getStages();
        var allStages = controllerStages.concat(this.get('ownStages')).reverse(); // ATTENTION: uses a side-effect: own stages will always be at start of array, so their mouse-over hooks need not be updated, when controller-stages change.
        this.get('screenContentAnchor').append(controller.rootElement()); // add to dom
        this.set('controllerStages', controllerStages);
        this.set('allStages', allStages); 
        this.bindEventHandlers(allStages, controller);
      }
    },
    
    remove: function(controller) {
      if (this.get('screenContentAnchor')) {
        var controllerStages = this.get('controllerStages');
        var allStages = this.get('allStages');
        this.unbindEventHandlers(allStages);
        this.set('controllerStages', []);
        this.set('allStages', this.get('ownStages').reverse()); // ATTENTION: uses a side-effect: own stages will always be at start of array, so their mouse-over hooks need not be updated, when controller-stages change.
        controller.rootElement().remove(); // remove from dom
      }
    },
    
    setScreenController: function(controller) {
      var rootController = this.get('presentScreenController');
      if (controller != rootController) {
        if (rootController) {
          rootController.viewWillDisappear();
          this.remove(rootController);
          rootController.viewDidDisappear();
        }
        this.set('presentScreenController', controller);
        if (controller) {
          controller.viewWillAppear();
          this.append(controller);
          controller.viewDidAppear();
        }
      }
    },
  
  }
}());






